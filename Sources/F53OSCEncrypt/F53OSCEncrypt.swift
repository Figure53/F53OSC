//
//  F53OSCEncrypt.swift
//  F53OSC
//
//  Created by Chad Sellers on 1/12/22.
//  Copyright (c) 2022-2025 Figure 53, LLC. All rights reserved.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//

import Foundation
import CryptoKit
import OSLog

@objc public class F53OSCEncrypt: NSObject {
    var keyPair: P521.KeyAgreement.PrivateKey?
    @objc public var peerKey: Data?
    var symmetricKey: SymmetricKey?
    @objc public var salt: Data?
    let logger = Logger(subsystem: Bundle.main.bundleIdentifier!, category: Bundle.main.infoDictionary!["CFBundleName"] as! String)

    @objc public override init()
    {
        super.init()
    }

    /// Initialize a new F53Encrypt object with a key pair previously generated by generateKeyPair()
    @objc public init(keyPairData: Data)
    {
        super.init()
        do
        {
            self.keyPair = try P521.KeyAgreement.PrivateKey(rawRepresentation: keyPairData)
        }
        catch
        {
            logger.error("Error reading key pair data for F53OSC encryption")
        }
    }

    /// Generate key pair.
    /// Note that caller is responsible for storing this to be used in later sessions
    @objc public func generateKeyPair() -> Data?
    {
        self.keyPair = P521.KeyAgreement.PrivateKey()
        logger.notice("F53OSC generated new key pair")
        return keyPairData()
    }

    /// Convenience method to get previously generated key pair
    @objc public func keyPairData() -> Data?
    {
        return self.keyPair?.rawRepresentation
    }

    /// Only the public key of the pair, to be sent to peer.
    /// Note that this is only available after the key pair has been generated
    @objc public func publicKeyData() -> Data?
    {
        return self.keyPair?.publicKey.rawRepresentation
    }

    /// Generate the salt to use for this session. Always generate a new salt for a new session.
    /// Note that only one end should create the salt. They should then send it to their peer,
    /// who should set the salt on their F53OSCEncrypt object.
    @objc public func generateSalt()
    {
        var saltData = Data()
        for _ in 1...20
        {
            var num = UInt64.random(in: 0...UInt64.max)
            saltData.append(Data(bytes: &num, count: 8))
        }
        self.salt = saltData
    }

    /// Setup encryption.
    /// @param peerKey public key data for the peer we are talking to
    @objc public func beginEncrypting(peerKey: Data) -> Bool
    {
        if let salt = self.salt
        {
            do
            {
                self.peerKey = peerKey
                let peerPubKey = try P521.KeyAgreement.PublicKey(rawRepresentation: peerKey)
                let sharedSecret = try keyPair?.sharedSecretFromKeyAgreement(with: peerPubKey)
                self.symmetricKey = sharedSecret?.hkdfDerivedSymmetricKey(using: SHA512.self, salt: salt, sharedInfo: Data(), outputByteCount: 32)
                logger.notice("F53OSC encryption begun")
                return true
            }
            catch
            {
                logger.error("Error creating public key from peer key data")
            }
        }
        else
        {
            logger.error("Error, cannot begin encrypting without salt")
        }
        return false
    }

    /// Encrypt some data.
    /// Note that beginEncrypting() must be called before this.
    /// @param clearData clear text data to be encrypted
    /// returns encrypted data
    @objc public func encryptData(clearData: Data) -> Data?
    {
        if let symkey = self.symmetricKey
        {
            do
            {
                let encryptedData = try ChaChaPoly.seal(clearData, using: symkey)
                return encryptedData.combined
            }
            catch
            {
                logger.error("Error encrypting data")
            }
        }
        else
        {
            logger.error("Error: trying to encrypt data when no key is set")
        }
        return nil
    }

    /// Decrypt some data.
    /// Note that beginEncrypting() must be called before this.
    /// @param encryptedData encrypted data to be decrypted
    /// returns clear text data
    @objc public func decryptData(encryptedData: Data) -> Data?
    {
        if let symkey = self.symmetricKey
        {
            do
            {
                let sealedBox = try ChaChaPoly.SealedBox(combined: encryptedData)
                let decryptedData = try ChaChaPoly.open(sealedBox, using: symkey)
                return decryptedData
            }
            catch
            {
                logger.error("Error decrypting data")
            }
        }
        else
        {
            logger.error("Error: trying to decrypt data when no key is set")
        }
        return nil
    }
}
