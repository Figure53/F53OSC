//
//  F53OSCEncrypt.swift
//  QLab
//
//  Created by Chad Sellers on 1/12/22.
//  Copyright Â© 2022 Figure 53, LLC. All rights reserved.
//

import Foundation
import Cocoa
import CryptoKit

@objc class F53OSCEncrypt: NSObject {
    var keyPair: P521.KeyAgreement.PrivateKey?
    var symmetricKey: SymmetricKey?
    @objc var salt: Data?

    @objc override init()
    {
        super.init()
    }

    /// Initialize a new F53Encrypt object with a key pair previously generated by generateKeyPair()
    @objc init(keyPairData: Data)
    {
        super.init()
        do
        {
            self.keyPair = try P521.KeyAgreement.PrivateKey(rawRepresentation: keyPairData)
        }
        catch
        {
            print("Error reading key pair data for F53OSC encryption")
        }
    }

    /// Generate key pair.
    /// Note that caller is responsible for storing this to be used in later sessions
    @objc func generateKeyPair() -> Data?
    {
        self.keyPair = P521.KeyAgreement.PrivateKey()
        return keyPairData()
    }

    /// Convenience method to get previously generated key pair
    @objc func keyPairData() -> Data?
    {
        return self.keyPair?.rawRepresentation
    }

    /// Only the public key of the pair, to be sent to peer.
    /// Note that this is only available after the key pair has been generated
    @objc func publicKeyData() -> Data?
    {
        return self.keyPair?.publicKey.rawRepresentation
    }

    /// Generate the salt to use for this session. Always generate a new salt for a new session.
    /// Note that only one end should create the salt. They should then send it to their peer,
    /// who should set the salt on their F53OSCEncrypt object.
    @objc func generateSalt()
    {
        var saltData = Data()
        for _ in 1...20
        {
            var num = UInt64.random(in: 0...UInt64.max)
            saltData.append(Data(bytes: &num, count: 8))
        }
        self.salt = saltData
    }

    /// Setup encryption.
    /// @param peerKey: public key data for the peer we are talking to
    @objc func beginEncrypting(peerKey: Data)
    {
        if let salt = self.salt
        {
            do
            {
                let peerPubKey = try P521.KeyAgreement.PublicKey(rawRepresentation: peerKey)
                let sharedSecret = try keyPair?.sharedSecretFromKeyAgreement(with: peerPubKey)
                self.symmetricKey = sharedSecret?.hkdfDerivedSymmetricKey(using: SHA512.self, salt: salt, sharedInfo: Data(), outputByteCount: 32)
            }
            catch
            {
                print("Error creating public key from peer key data")
            }
        }
        else
        {
            print("Error, cannot begin encrypting without salt")
        }
    }

    /// Encrypt some data.
    /// Note that beginEncrypting() must be called before this.
    /// @param clearData: clear text data to be encrypted
    /// returns encrypted data
    @objc func encryptData(clearData: Data) -> Data?
    {
        if let symkey = self.symmetricKey
        {
            do
            {
                let encryptedData = try ChaChaPoly.seal(clearData, using: symkey)
                return encryptedData.combined
            }
            catch
            {
                print("Error encrypting data")
            }
        }
        else
        {
            print("Error: trying to encrypt data when no key is set")
        }
        return nil
    }

    /// Decrypt some data.
    /// Note that beginEncrypting() must be called before this.
    /// @param encryptedData: encrypted data to be decrypted
    /// returns clear text data
    @objc func decryptData(encryptedData: Data) -> Data?
    {
        if let symkey = self.symmetricKey
        {
            do
            {
                let sealedBox = try ChaChaPoly.SealedBox(combined: encryptedData)
                let decryptedData = try ChaChaPoly.open(sealedBox, using: symkey)
                return decryptedData
            }
            catch
            {
                print("Error decrypting data")
            }
        }
        else
        {
            print("Error: trying to decrypt data when no key is set")
        }
        return nil
    }
}
