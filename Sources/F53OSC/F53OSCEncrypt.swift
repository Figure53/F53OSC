//
//  F53OSCEncrypt.swift
//  QLab
//
//  Created by Chad Sellers on 1/12/22.
//  Copyright Â© 2022 Figure 53, LLC. All rights reserved.
//

import Foundation
import CryptoKit
import OSLog

@objc public class F53OSCEncrypt: NSObject {
    var keyPair: P521.KeyAgreement.PrivateKey?
    @objc public var peerKey: Data?
    var symmetricKey: SymmetricKey?
    @objc public var salt: Data?
    let logger = Logger(subsystem: Bundle.main.bundleIdentifier!, category: Bundle.main.infoDictionary!["CFBundleName"] as! String)

    @objc public override init()
    {
        super.init()
    }

    /// Initialize a new F53Encrypt object with a key pair previously generated by generateKeyPair()
    @objc public init(keyPairData: Data)
    {
        super.init()
        do
        {
            self.keyPair = try P521.KeyAgreement.PrivateKey(rawRepresentation: keyPairData)
        }
        catch
        {
            logger.error("Error reading key pair data for F53OSC encryption")
        }
    }

    /// Generate key pair.
    /// Note that caller is responsible for storing this to be used in later sessions
    @objc public func generateKeyPair() -> Data?
    {
        self.keyPair = P521.KeyAgreement.PrivateKey()
        logger.notice("F53OSC generated new key pair")
        return keyPairData()
    }

    /// Convenience method to get previously generated key pair
    @objc public func keyPairData() -> Data?
    {
        return self.keyPair?.rawRepresentation
    }

    /// Only the public key of the pair, to be sent to peer.
    /// Note that this is only available after the key pair has been generated
    @objc public func publicKeyData() -> Data?
    {
        return self.keyPair?.publicKey.rawRepresentation
    }

    /// Generate the salt to use for this session. Always generate a new salt for a new session.
    /// Note that only one end should create the salt. They should then send it to their peer,
    /// who should set the salt on their F53OSCEncrypt object.
    @objc public func generateSalt()
    {
        var saltData = Data()
        for _ in 1...20
        {
            var num = UInt64.random(in: 0...UInt64.max)
            saltData.append(Data(bytes: &num, count: 8))
        }
        self.salt = saltData
    }

    /// Setup encryption.
    /// @param peerKey public key data for the peer we are talking to
    @objc public func beginEncrypting(peerKey: Data) -> Bool
    {
        if let salt = self.salt
        {
            do
            {
                self.peerKey = peerKey
                let peerPubKey = try P521.KeyAgreement.PublicKey(rawRepresentation: peerKey)
                let sharedSecret = try keyPair?.sharedSecretFromKeyAgreement(with: peerPubKey)
                self.symmetricKey = sharedSecret?.hkdfDerivedSymmetricKey(using: SHA512.self, salt: salt, sharedInfo: Data(), outputByteCount: 32)
                logger.notice("F53OSC encryption begun")
                return true
            }
            catch
            {
                logger.error("Error creating public key from peer key data")
            }
        }
        else
        {
            logger.error("Error, cannot begin encrypting without salt")
        }
        return false
    }

    /// Encrypt some data.
    /// Note that beginEncrypting() must be called before this.
    /// @param clearData clear text data to be encrypted
    /// returns encrypted data
    @objc public func encryptData(clearData: Data) -> Data?
    {
        if let symkey = self.symmetricKey
        {
            do
            {
                let encryptedData = try ChaChaPoly.seal(clearData, using: symkey)
                return encryptedData.combined
            }
            catch
            {
                logger.error("Error encrypting data")
            }
        }
        else
        {
            logger.error("Error: trying to encrypt data when no key is set")
        }
        return nil
    }

    /// Decrypt some data.
    /// Note that beginEncrypting() must be called before this.
    /// @param encryptedData encrypted data to be decrypted
    /// returns clear text data
    @objc public func decryptData(encryptedData: Data) -> Data?
    {
        if let symkey = self.symmetricKey
        {
            do
            {
                let sealedBox = try ChaChaPoly.SealedBox(combined: encryptedData)
                let decryptedData = try ChaChaPoly.open(sealedBox, using: symkey)
                return decryptedData
            }
            catch
            {
                logger.error("Error decrypting data")
            }
        }
        else
        {
            logger.error("Error: trying to decrypt data when no key is set")
        }
        return nil
    }
}
